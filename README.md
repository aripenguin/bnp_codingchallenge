# bnp_codingchallenge
#BNP Data Scientist Technical Exam
#Applicant - Ariann Chai

#Instructions:
#The two output names are: _.csv, .png
#The third is a popup graph



#Question 1: I used csv.reader in readCSV() to go through the csv file given line by line. With the help of singleName() (to split if there is more than one sender or receiver), personArr() stores all sender or receiver names in a dictionary/hash table called people. The person's name becomes a key and the value is a size two array [# of email sent by person, # of emails recieved by person] which is added to whether that person shows up in sender or receiver (2=sender, 3-receiver). This is done by testing if person name is a key in people and adding them with a value of [0,0] to start. Then, the program calls writeCSV() to make the new .csv file with the data in people being sorted as it reads it (highest to lowest # of emails sent).

#Question 2: In order to get the names of the people who are the top 5 senders, I added a count variable in the for loop in writeCSV(), that will store the first 5 people into a new array called top. Due to the sort on people, these are the top 5 senders. In order to find out the progress of the amount of emails send for each, I made dictionary named top_send that holds the top 5 people's names as key and each have a size 9 int array as the value for the 9 timestamps I used. I choose to set my time stamps at 9 because the data given is from May 1998 - Dec 2002 so semi-annually seems like a good count for now. (The first half of 1998 has one email and it was not one of the top 5 so I chosen to ignore it). The functions createTimestamp and findTimestamp open up a new read to the csv file in search of the top 5 people and upon finding one of them as a sender, adds one to that person's int array in the position that correlates to that timestamp. After collecting the data, I made a png image of a line graph where each line represents a top 5 person's sent emails over the timeline.

#Question 3: In the same functions createTimestamp and findTimestamp, it also searches for when a top 5 people is the receiver of an email and saves it like in top_send, but instead in top_receive. However, there is some extra steps are we are counting for unique senders. Top1, top2, top3, top4, top5 are dictionaries that hold people who have contacted them over the timeline (with the value being the correlating timestamp). The program tests to see if a sender is already in the dictionary for that top 5 person to keep the uniqueness. This also means that the person has to come out of the dictionary completely and his partication in the timestamp count. After this, I used for loops to check uniqueness across the the top 5 people and if a person came up in other dictionary, I subtracted one in the timestamp of their key value in unique_receive. Unique_receive is a duplicate of top_receive were the number of unique senders to each top 5 should lower as they are compared to each other. I then used a line graph to show 2 lines (a straight for raw unique and a dashed for relative unique) for each top 5 person's unique senders over the timeline.
